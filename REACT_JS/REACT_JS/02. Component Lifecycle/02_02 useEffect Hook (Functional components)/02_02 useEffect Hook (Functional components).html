<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React useEffect Questions</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .question {
            background: #fff;
            border-left: 5px solid #3498db;
            padding: 20px;
            margin: 20px auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 900px;
            border-radius: 8px;
        }
        .question h2 {
            margin-top: 0;
            color: #2980b9;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            overflow-x: auto;
            border-radius: 5px;
        }
        code {
            font-family: monospace;
            white-space: pre-wrap; /* Allow wrapping for long lines */
        }
    </style>
</head>
<body>
    <h1>React useEffect Hook Questions</h1>

    <!-- Question 1 -->
    <div class="question">
        <h2>1. What is the purpose of the `useEffect` hook in React?</h2>
        <p>The `useEffect` hook allows you to perform side effects in functional components. It is commonly used for operations like fetching data, subscribing to a service, or manually changing the DOM after a render.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ExampleComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  }, [count]);  // Effect runs when `count` changes

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 2 -->
    <div class="question">
        <h2>2. How does the `useEffect` hook handle side effects in functional components?</h2>
        <p>The `useEffect` hook is called after the render, allowing you to perform side effects such as fetching data, updating the DOM, or subscribing to external events. By default, it runs after every render, but you can control when it runs using the dependency array.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DataFetcher = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    fetch('https://api.example.com/data')
      .then((response) =&gt; response.json())
      .then((data) =&gt; setData(data));
  }, []);  // Runs only once after the initial render

  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...' }&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 3 -->
    <div class="question">
        <h2>3. What does the empty dependency array `[]` mean in `useEffect`?</h2>
        <p>An empty dependency array `[]` means that the effect will run only once, similar to `componentDidMount` in class components. This is used for operations that should happen only once when the component mounts.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const Component = () =&gt; {
  useEffect(() =&gt; {
    console.log('This effect runs only once, after the initial render');
  }, []);  // Empty array ensures the effect only runs once

  return &lt;div&gt;Check the console&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 4 -->
    <div class="question">
        <h2>4. How do you clean up side effects in `useEffect`?</h2>
        <p>You can clean up side effects by returning a function from the `useEffect` callback. This cleanup function is run when the component is unmounted or before the effect is re-run (if the dependencies change).</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const TimerComponent = () =&gt; {
  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      console.log('Timer is running');
    }, 1000);

    return () =&gt; {
      clearInterval(timer);  // Cleanup the timer on unmount
    };
  }, []);  // Runs once when the component mounts

  return &lt;div&gt;Check the console for the timer&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 5 -->
    <div class="question">
        <h2>5. How can you make `useEffect` run conditionally in React?</h2>
        <p>You can make `useEffect` run conditionally by adding dependencies in the dependency array. The effect will run only when the specified state or props change.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ConditionalEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    if (count &gt; 5) {
      console.log('Count is greater than 5');
    }
  }, [count]);  // Effect runs only when `count` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 6 -->
    <div class="question">
        <h2>6. How can you conditionally run a `useEffect` hook based on state or props?</h2>
        <p>You can conditionally run a `useEffect` hook by using a dependency array that includes only the state or props you want to trigger the effect. This ensures that the effect runs only when the specified state or props change.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ExampleComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    if (count &gt; 5) {
      console.log('Count is greater than 5');
    }
  }, [count]);  // Effect runs only when `count` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 7 -->
    <div class="question">
        <h2>7. How does `useEffect` work with asynchronous code like API calls?</h2>
        <p>The `useEffect` hook can be used with asynchronous code like API calls. However, you should not make the `useEffect` callback itself async. Instead, use an inner async function to handle the asynchronous operations.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const FetchDataComponent = () =&gt; {
  const [data, setData] = useState(null);
  
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };
    
    fetchData();
  }, []);  // Runs once when the component mounts
  
  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 8 -->
    <div class="question">
        <h2>8. How can you delay the execution of a `useEffect` hook in React?</h2>
        <p>You can delay the execution of a `useEffect` hook by using `setTimeout` or `setInterval` inside the effect. The cleanup function can be used to clear these timers when the component unmounts or when dependencies change.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const TimerDelayComponent = () =&gt; {
  const [message, setMessage] = useState('');

  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {
      setMessage('This message is delayed!');
    }, 3000);  // Delay of 3 seconds

    return () =&gt; clearTimeout(timer);  // Cleanup on unmount or when effect re-runs
  }, []);  // Runs once when the component mounts

  return &lt;div&gt;{message}&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 9 -->
    <div class="question">
        <h2>9. Can `useEffect` run multiple times within the same component?</h2>
        <p>Yes, you can have multiple `useEffect` hooks in the same component. React executes each `useEffect` hook independently, in the order they appear in the component.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleEffectsComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    console.log('Count updated:', count);
  }, [count]);  // Runs when `count` changes

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };
    fetchData();
  }, []);  // Runs once when component mounts
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;p&gt;Data: {data ? JSON.stringify(data) : 'Loading...'}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 10 -->
    <div class="question">
        <h2>10. How can you prevent a `useEffect` hook from running on every render?</h2>
        <p>You can prevent a `useEffect` hook from running on every render by providing a dependency array. If the array is empty, the effect will run only once when the component mounts, similar to `componentDidMount`.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const PreventEffectReRunComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Component mounted');
  }, []);  // Empty array ensures it only runs once

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 11 -->
    <div class="question">
        <h2>11. How can you fetch data inside `useEffect` in React?</h2>
        <p>You can fetch data inside a `useEffect` hook by calling an asynchronous function within the effect. The `useEffect` will run once when the component mounts, or whenever the dependencies change, depending on the dependency array provided.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DataFetchingComponent = () =&gt; {
  const [data, setData] = useState(null);
  
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };
    
    fetchData();
  }, []);  // Runs once when the component mounts
  
  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 12 -->
    <div class="question">
        <h2>12. How does `useEffect` behave when there are multiple dependencies?</h2>
        <p>When there are multiple dependencies in the dependency array of `useEffect`, the effect will rerun whenever any of the values in the array change. It allows for more precise control over the effect execution based on the state or props changes.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleDependenciesComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('John');

  useEffect(() =&gt; {
    console.log(`Count: ${count}, Name: ${name}`);
  }, [count, name]);  // Runs when either `count` or `name` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;p&gt;Name: {name}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment Count&lt;/button&gt;
      &lt;button onClick={() =&gt; setName('Alice')}&gt;Change Name&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 13 -->
    <div class="question">
        <h2>13. What is the behavior of `useEffect` when it has an empty dependency array?</h2>
        <p>If the dependency array of `useEffect` is empty, the effect will run only once after the initial render, similar to `componentDidMount` in class components. It will not run on subsequent re-renders.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ComponentWithEmptyDependencyArray = () =&gt; {
  const [message, setMessage] = useState('Hello');

  useEffect(() =&gt; {
    console.log('Effect ran once');
  }, []);  // Runs only once when the component mounts

  return &lt;div&gt;{message}&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 14 -->
    <div class="question">
        <h2>14. How can you return a cleanup function from `useEffect` in React?</h2>
        <p>You can return a cleanup function from `useEffect` to clean up resources like timers, event listeners, or subscriptions when the component unmounts or before the effect re-runs due to a change in dependencies.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const CleanupExampleComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      console.log('Interval running');
    }, 1000);

    // Cleanup function
    return () =&gt; clearInterval(interval);  // Clears interval when component unmounts or effect reruns
  }, []);  // Runs once on mount

  return &lt;div&gt;
    &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
  &lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 15 -->
    <div class="question">
        <h2>15. Can you use `useEffect` to manipulate the DOM directly in React?</h2>
        <p>Yes, `useEffect` can be used to manipulate the DOM directly if needed. However, this is generally discouraged, as React is designed to manage the DOM efficiently. Use it carefully when necessary, such as for integrating with third-party libraries.</p>
        <pre><code>&lt;import React, { useEffect } from 'react';&gt;

const DirectDOMManipulationComponent = () =&gt; {
  useEffect(() =&gt; {
    const element = document.getElementById('special-element');
    if (element) {
      element.style.backgroundColor = 'yellow';
    }
  }, []);  // Runs once when the component mounts

  return &lt;div&gt;
    &lt;p&gt;Manipulating the DOM directly:&lt;/p&gt;
    &lt;div id="special-element"&gt;This will have a yellow background.&lt;/div&gt;
  &lt;/div&gt;;
};</code></pre>
    </div>
    
        <!-- Question 16 -->
    <div class="question">
        <h2>16. Can `useEffect` be used to run effects after rendering in React?</h2>
        <p>Yes, `useEffect` can run after the component renders. It is executed after the render phase, making it ideal for handling side-effects like data fetching or manual DOM manipulation.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const AfterRenderComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Effect after render: Count is', count);
  }, [count]);  // Runs after every render when `count` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 17 -->
    <div class="question">
        <h2>17. How can `useEffect` hook be used for cleanup in React?</h2>
        <p>The `useEffect` hook can return a cleanup function. This function is executed when the component unmounts or before the effect re-runs due to a change in dependencies. It helps clean up side effects like event listeners or subscriptions.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const CleanupComponent = () =&gt; {
  useEffect(() =&gt; {
    const handleResize = () =&gt; {
      console.log('Window resized');
    };

    // Adding event listener
    window.addEventListener('resize', handleResize);

    // Cleanup function
    return () =&gt; window.removeEventListener('resize', handleResize);
  }, []);  // Runs once when component mounts

  return &lt;div&gt;Resize the window to see the effect.&lt;/div&gt;
};</code></pre>
    </div>

    <!-- Question 18 -->
    <div class="question">
        <h2>18. How do you handle multiple state changes with `useEffect` in React?</h2>
        <p>You can handle multiple state changes by using multiple `useEffect` hooks or by including multiple state variables in the dependency array of a single `useEffect` hook. React will run the effect when any of the state variables change.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleStateChangesComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('John');

  useEffect(() =&gt; {
    console.log(`Count changed to: ${count}`);
  }, [count]);  // Runs when `count` changes

  useEffect(() =&gt; {
    console.log(`Name changed to: ${name}`);
  }, [name]);  // Runs when `name` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;p&gt;Name: {name}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment Count&lt;/button&gt;
      &lt;button onClick={() =&gt; setName('Alice')}&gt;Change Name&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 19 -->
    <div class="question">
        <h2>19. What happens if you leave the dependency array empty in `useEffect` in React?</h2>
        <p>If you leave the dependency array empty (`[]`), `useEffect` will run only once when the component mounts. It will not re-run on any subsequent renders. This is similar to how `componentDidMount` works in class components.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const EmptyDependencyComponent = () =&gt; {
  const [message, setMessage] = useState('Hello');

  useEffect(() =&gt; {
    console.log('Effect ran once');
  }, []);  // Runs once on mount

  return &lt;div&gt;{message}&lt;/div&gt;;
};</code></pre>
    </div>

    <!-- Question 20 -->
    <div class="question">
        <h2>20. How can `useEffect` be used with `localStorage` in React?</h2>
        <p>You can use `useEffect` to interact with `localStorage` by reading from it when the component mounts or by updating it when the component’s state changes. This allows you to persist data between page reloads.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const LocalStorageComponent = () =&gt; {
  const [name, setName] = useState('');

  useEffect(() =&gt; {
    const savedName = localStorage.getItem('name');
    if (savedName) {
      setName(savedName);
    }
  }, []);  // Runs once on mount

  useEffect(() =&gt; {
    if (name) {
      localStorage.setItem('name', name);
    }
  }, [name]);  // Runs when `name` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Stored Name: {name}&lt;/p&gt;
      &lt;input
        type="text"
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
        placeholder="Enter your name"
      /&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 21 -->
    <div class="question">
        <h2>21. How can `useEffect` be used to set the document title in React?</h2>
        <p>You can use `useEffect` to change the document title whenever a state or prop changes. This is useful for dynamically updating the title based on the component's state or the page the user is on.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const TitleUpdaterComponent = () =&gt; {
  const [title, setTitle] = useState('Initial Title');

  useEffect(() =&gt; {
    document.title = title;  // Update document title
  }, [title]);  // Runs when `title` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Current Title: {title}&lt;/p&gt;
      &lt;button onClick={() =&gt; setTitle('New Title')}&gt;Change Title&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 22 -->
    <div class="question">
        <h2>22. Can `useEffect` handle asynchronous operations in React?</h2>
        <p>Yes, `useEffect` can handle asynchronous operations like fetching data, but you cannot directly make the `useEffect` function async. Instead, you define an async function inside the `useEffect` callback and call it.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const AsyncEffectComponent = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();  // Invoke async function inside useEffect
  }, []);  // Runs once when component mounts

  return (
    &lt;div&gt;
      {data ? JSON.stringify(data) : 'Loading...'}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 23 -->
    <div class="question">
        <h2>23. How can you prevent `useEffect` from running on initial mount?</h2>
        <p>To prevent `useEffect` from running on the initial mount, you can use a flag or modify the dependency array based on your needs. For example, you can track whether the component has already mounted by using a `useState` variable.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const PreventInitialRunComponent = () =&gt; {
  const [hasMounted, setHasMounted] = useState(false);

  useEffect(() =&gt; {
    if (hasMounted) {
      console.log('Effect runs after initial mount');
    } else {
      setHasMounted(true);  // Set flag after first render
    }
  }, [hasMounted]);  // Runs when `hasMounted` changes

  return &lt;div&gt;Check console for effect output.&lt;/div&gt;
};</code></pre>
    </div>

    <!-- Question 24 -->
    <div class="question">
        <h2>24. What is the default behavior of `useEffect` with no dependency array?</h2>
        <p>If `useEffect` is used without a dependency array, the effect will run after every render of the component. This includes the initial render and all subsequent updates.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const EffectWithoutDependenciesComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Effect runs after every render');
  });  // No dependency array, runs after every render

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 25 -->
    <div class="question">
        <h2>25. How does `useEffect` work with multiple `useState` calls in a React component?</h2>
        <p>`useEffect` will run after every render, and it can listen to multiple states. If you pass multiple state variables in the dependency array, the effect will run whenever any of those state variables change.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleStateComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('John');

  useEffect(() =&gt; {
    console.log(`Effect runs because count or name changed. Count: ${count}, Name: ${name}`);
  }, [count, name]);  // Runs when either `count` or `name` changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;p&gt;Name: {name}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment Count&lt;/button&gt;
      &lt;button onClick={() =&gt; setName('Alice')}&gt;Change Name&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 26 -->
    <div class="question">
        <h2>26. How can you use `useEffect` to fetch data in a React component?</h2>
        <p>You can use the `useEffect` hook to fetch data when the component mounts. You typically do this by making the fetch call inside an asynchronous function defined within the `useEffect` hook.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DataFetchComponent = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();  // Invoke async function inside useEffect
  }, []);  // Runs once on mount

  return (
    &lt;div&gt;
      {data ? JSON.stringify(data) : 'Loading...'}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 27 -->
    <div class="question">
        <h2>27. How do you use `useEffect` with `setInterval` in React?</h2>
        <p>You can use `setInterval` inside `useEffect` to perform actions at regular intervals, but you need to clear the interval when the component unmounts to prevent memory leaks.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const IntervalComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setCount(prevCount =&gt; prevCount + 1);
    }, 1000);

    // Cleanup the interval when the component unmounts
    return () =&gt; clearInterval(interval);
  }, []);  // Runs once on mount

  return &lt;div&gt;
    Count: {count}
  &lt;/div&gt;
};</code></pre>
    </div>

    <!-- Question 28 -->
    <div class="question">
        <h2>28. Can you use `useEffect` with multiple side effects?</h2>
        <p>Yes, you can run multiple side effects within a single `useEffect` hook. You can do this by placing multiple actions inside the function body. Alternatively, you can use multiple `useEffect` hooks for separate side effects.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleEffectsComponent = () =&gt; {
  const [data, setData] = useState(null);
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();  // Fetch data

    // Side effect 2: Update count every time data changes
    if (data) {
      setCount(count + 1);
    }
  }, [data]);  // Dependency array to trigger when `data` changes

  return (
    &lt;div&gt;
      {data ? JSON.stringify(data) : 'Loading...'}<br/>
      Count: {count}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 29 -->
    <div class="question">
        <h2>29. How can `useEffect` be used with external libraries like Axios?</h2>
        <p>You can use `useEffect` to fetch data using external libraries like Axios. Just like with the built-in `fetch` API, make the Axios call inside an asynchronous function in the `useEffect` callback.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';
import axios from 'axios';&gt;

const AxiosFetchComponent = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        const response = await axios.get('https://api.example.com/data');
        setData(response.data);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();  // Invoke async function inside useEffect
  }, []);  // Runs once on mount

  return (
    &lt;div&gt;
      {data ? JSON.stringify(data) : 'Loading...'}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 30 -->
    <div class="question">

        <h2>30. How do you conditionally run `useEffect` only when certain state values change?</h2>
        <p>You can conditionally run `useEffect` by specifying the state or prop values in the dependency array. The effect will only run when one of those values changes.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ConditionalEffectComponent = () =&gt; {
  const [isActive, setIsActive] = useState(true);

  useEffect(() =&gt; {
    if (isActive) {
      console.log('Effect runs because isActive is true');
    }
  }, [isActive]);  // Runs only when `isActive` changes

  return (
    &lt;div&gt;
      <button onClick={() =&gt; setIsActive(!isActive)}>{isActive ? 'Deactivate' : 'Activate'}</button>
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 31 -->
    <div class="question">
        <h2>31. How do you use `useEffect` to execute a side effect only on component unmount?</h2>
        <p>You can use the cleanup function inside `useEffect` to execute a side effect when the component unmounts. This is commonly used for cleaning up resources like timers, network requests, etc.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const CleanupEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; setCount(count + 1), 1000);

    // Cleanup function to clear the timer on unmount
    return () =&gt; clearInterval(timer);
  }, []);  // Runs once on mount, cleanup on unmount

  return (
    &lt;div&gt;
      Count: {count}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 32 -->
    <div class="question">
        <h2>32. How can `useEffect` be used to set up event listeners?</h2>
        <p>You can use `useEffect` to add event listeners such as mouse clicks, key presses, etc. Inside the `useEffect` callback, you add the event listener, and in the cleanup function, you remove it.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const EventListenerComponent = () =&gt; {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  useEffect(() =&gt; {
    const handleMouseMove = (event) =&gt; {
      setMousePosition({ x: event.clientX, y: event.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);

    // Cleanup the event listener when the component unmounts
    return () =&gt; window.removeEventListener('mousemove', handleMouseMove);
  }, []);  // Runs once on mount, cleans up on unmount

  return (
    &lt;div&gt;
      Mouse Position: {`x: ${mousePosition.x}, y: ${mousePosition.y}`}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 33 -->
    <div class="question">
        <h2>33. How does `useEffect` work when you need to perform cleanup on every render?</h2>
        <p>If you want to perform cleanup on every render, you can return a cleanup function inside the `useEffect` hook. This will run before every re-run of the effect, ensuring that any previous side effects are cleaned up.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const CleanupOnEveryRenderComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Effect runs');
    
    // Cleanup before every render
    return () =&gt; console.log('Cleanup before render');
  }, [count]);  // Runs on every render when `count` changes

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 34 -->
    <div class="question">
        <h2>34. What happens if you pass an empty dependency array to `useEffect`?</h2>
        <p>If you pass an empty dependency array (`[]`) to `useEffect`, it will only run the effect once, when the component mounts, and will not run again on subsequent renders. This is useful for actions that should only happen once, such as fetching data or adding event listeners on mount.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MountEffectComponent = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();  // Only runs once on mount

  }, []);  // Empty array means this effect only runs once when the component mounts

  return (
    &lt;div&gt;
      {data ? JSON.stringify(data) : 'Loading...'}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 35 -->
    <div class="question">
        <h2>35. Can you use `useEffect` to subscribe to an external store or data source?</h2>
        <p>Yes, you can use `useEffect` to subscribe to external data sources or stores (e.g., Redux, WebSocket connections). You typically start the subscription in the `useEffect` hook and clean it up when the component unmounts to avoid memory leaks.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ExternalDataComponent = () =&gt; {
  const [message, setMessage] = useState('');

  useEffect(() =&gt; {
    const handleNewMessage = (newMessage) =&gt; {
      setMessage(newMessage);
    };

    // Simulate subscribing to an external data source (e.g., WebSocket)
    const messageSource = new EventSource('/api/messages');
    messageSource.addEventListener('message', (event) =&gt; handleNewMessage(event.data));

    // Cleanup the subscription when the component unmounts
    return () =&gt; messageSource.close();
  }, []);  // Runs once on mount, cleans up on unmount

  return (
    &lt;div&gt;
      New Message: {message}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 36 -->
    <div class="question">
        <h2>36. How can you optimize `useEffect` performance when working with expensive operations?</h2>
        <p>You can optimize `useEffect` performance by carefully choosing the dependencies in the dependency array and by using memoization techniques. For example, using `useMemo` or `useCallback` can prevent unnecessary re-executions of expensive operations.</p>
        <pre><code>&lt;import React, { useState, useEffect, useMemo } from 'react';&gt;

const ExpensiveOperationComponent = () =&gt; {
  const [input, setInput] = useState('');

  const expensiveCalculation = useMemo(() =&gt; {
    console.log('Expensive calculation running...');
    return input.split('').reverse().join('');
  }, [input]);  // Only recompute when `input` changes

  return (
    &lt;div&gt;
      &lt;input type="text" value={input} onChange={(e) =&gt; setInput(e.target.value)} /&gt;
      &lt;p&gt;Result: {expensiveCalculation}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 37 -->
    <div class="question">
        <h2>37. How do you use `useEffect` to watch for prop changes in a React component?</h2>
        <p>You can watch for prop changes by passing the prop as a dependency in the `useEffect` hook. This way, the effect will run whenever the value of the prop changes.</p>
        <pre><code>&lt;import React, { useEffect } from 'react';&gt;

const PropWatcherComponent = ({ message }) =&gt; {
  useEffect(() =&gt; {
    console.log('Message prop has changed:', message);
  }, [message]);  // Runs every time `message` changes

  return (
    &lt;div&gt;
      Current Message: {message}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 38 -->
    <div class="question">
        <h2>38. How do you perform side effects that depend on multiple state values in `useEffect`?</h2>
        <p>If the side effect depends on multiple state values, you can pass them all in the dependency array. The effect will run whenever any of these state values change.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleStateEffectComponent = () =&gt; {
  const [name, setName] = useState('');
  const [age, setAge] = useState(0);

  useEffect(() =&gt; {
    console.log(`Name: ${name}, Age: ${age}`);
  }, [name, age]);  // Runs whenever `name` or `age` changes

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
        placeholder="Enter your name"
      /&gt;
      &lt;input
        type="number"
        value={age}
        onChange={(e) =&gt; setAge(e.target.value)}
        placeholder="Enter your age"
      /&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 39 -->
    <div class="question">
        <h2>39. Can `useEffect` be used to make the component rerender?</h2>
        <p>Yes, `useEffect` can be used to trigger a rerender by updating the state inside the effect. When the state is updated, React triggers a rerender of the component.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const RerenderComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    if (count &gt; 5) {
      setCount(0);  // This will trigger a rerender
    }
  }, [count]);  // Runs every time `count` changes

  return (
    &lt;div&gt;
      Count: {count}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 40 -->
    <div class="question">
        <h2>40. How do you prevent `useEffect` from running on initial render?</h2>
        <p>You can prevent `useEffect` from running on the initial render by using a ref or by adding a condition in the effect to check whether it's the first render.</p>
        <pre><code>&lt;import React, { useState, useEffect, useRef } from 'react';&gt;

const SkipFirstRenderEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const isFirstRender = useRef(true);

  useEffect(() =&gt; {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;  // Skip effect on first render
    }

    // Your effect logic here
    console.log('Effect ran on state change');

  }, [count]);  // Runs on every `count` change except the first time

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 41 -->
    <div class="question">
        <h2>41. How can you perform side effects after an async operation in `useEffect`?</h2>
        <p>To perform side effects after an async operation, you should declare an async function inside `useEffect` and invoke it. Since `useEffect` itself cannot return a promise, the async function must be called within it.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const AsyncEffectComponent = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };

    fetchData();  // Call async function inside useEffect

  }, []);  // Only runs once when the component mounts

  return (
    &lt;div&gt;
      {data ? JSON.stringify(data) : 'Loading...'}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 42 -->
    <div class="question">
        <h2>42. How do you fetch data inside `useEffect`?</h2>
        <p>To fetch data inside `useEffect`, you can call an async function within the hook, such as a `fetch` request. Be sure to handle loading states and errors appropriately.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DataFetchingComponent = () =&gt; {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        const response = await fetch('https://api.example.com/data');
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();  // Fetch data when component mounts

  }, []);  // Empty array to run once on mount

  return (
    &lt;div&gt;
      {loading ? 'Loading...' : JSON.stringify(data)}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 43 -->
    <div class="question">
        <h2>43. How can you manage side effects that depend on dynamic data using `useEffect`?</h2>
        <p>You can manage side effects that depend on dynamic data by passing the relevant state variables as dependencies in the dependency array. This ensures the effect is triggered whenever the data changes.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DynamicDataEffectComponent = () =&gt; {
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(`https://api.example.com/data?search=${searchTerm}`);
      const result = await response.json();
      setData(result);
    };

    if (searchTerm) {
      fetchData();  // Fetch data whenever `searchTerm` changes
    }

  }, [searchTerm]);  // Runs when `searchTerm` changes

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={searchTerm}
        onChange={(e) =&gt; setSearchTerm(e.target.value)}
        placeholder="Search data"
      /&gt;
      {data.length &gt; 0 ? JSON.stringify(data) : 'No results'}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 44 -->
    <div class="question">
        <h2>44. What is the importance of the dependency array in `useEffect`?</h2>
        <p>The dependency array is used to specify which values should trigger the effect. If the values in the array change, the effect will rerun. If the array is empty, the effect will only run once, when the component mounts.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DependencyArrayComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Effect runs when count changes:', count);
  }, [count]);  // Runs when `count` changes

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 45 -->
    <div class="question">
        <h2>45. How do you handle an effect that should only run when specific conditions are met?</h2>
        <p>You can control when an effect should run by using conditional logic within the `useEffect` hook. This allows you to only perform side effects when certain conditions are true.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const ConditionalEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    if (count &gt; 5) {
      console.log('Effect runs because count is greater than 5');
    }
  }, [count]);  // Runs whenever `count` changes

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>
    
        <!-- Question 46 -->
    <div class="question">
        <h2>46. How can you clean up resources in `useEffect`?</h2>
        <p>You can clean up resources in `useEffect` by returning a cleanup function from the effect. This cleanup function will run when the component is unmounted or before the effect runs again.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const CleanupEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      console.log('Timer running...');
    }, 1000);

    return () =&gt; {
      clearInterval(timer);  // Cleanup timer when component unmounts or effect reruns
      console.log('Cleanup running...');
    };
  }, []);  // Empty array ensures this effect only runs on mount and unmount

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 47 -->
    <div class="question">
        <h2>47. Can you use multiple `useEffect` hooks in a component?</h2>
        <p>Yes, you can use multiple `useEffect` hooks in a component. Each `useEffect` hook can serve a different purpose, such as handling different side effects or dealing with different dependencies.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const MultipleEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  useEffect(() =&gt; {
    console.log('Count effect running...');
  }, [count]);  // Runs when `count` changes

  useEffect(() =&gt; {
    console.log('Name effect running...');
  }, [name]);  // Runs when `name` changes

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      <br />
      Name: {name}
      &lt;input
        type="text"
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
        placeholder="Enter name"
      /&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 48 -->
    <div class="question">
        <h2>48. How can you use `useEffect` for component lifecycle events?</h2>
        <p>You can simulate component lifecycle events using `useEffect`. For example, `useEffect` with an empty dependency array simulates `componentDidMount`, and `useEffect` with specific dependencies simulates `componentDidUpdate`.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const LifecycleEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);

  // Simulates componentDidMount
  useEffect(() =&gt; {
    console.log('Component mounted');
  }, []);  // Empty dependency array

  // Simulates componentDidUpdate
  useEffect(() =&gt; {
    console.log('Component updated');
  }, [count]);  // Runs when `count` changes

  return (
    &lt;div&gt;
      Count: {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 49 -->
    <div class="question">
        <h2>49. How do you fetch data with `useEffect` and manage loading states?</h2>
        <p>To fetch data with `useEffect` and manage loading states, you can use state variables to track whether the data is still loading. You can update the loading state before and after fetching the data.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const DataFetchingWithLoadingState = () =&gt; {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      setLoading(true);  // Start loading
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
      setLoading(false);  // End loading
    };

    fetchData();

  }, []);  // Fetch data once on component mount

  return (
    &lt;div&gt;
      {loading ? 'Loading...' : JSON.stringify(data)}
    &lt;/div&gt;
  );
};</code></pre>
    </div>

    <!-- Question 50 -->
    <div class="question">
        <h2>50. How can you avoid infinite loops in `useEffect`?</h2>
        <p>To avoid infinite loops in `useEffect`, ensure that you don't accidentally create circular dependencies in the dependency array. If an effect updates state that triggers the effect again, it can lead to an infinite loop. Always ensure the effect is only triggered when necessary.</p>
        <pre><code>&lt;import React, { useState, useEffect } from 'react';&gt;

const PreventInfiniteLoopEffectComponent = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    if (count &lt; 5) {
      setCount(count + 1);  // Avoid triggering this effect indefinitely
    }
  }, [count]);  // Avoid infinite loop by careful state change logic

  return (
    &lt;div&gt;
      Count: {count}
    &lt;/div&gt;
  );
};</code></pre>
    </div>


</body>
</html>
