<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>React useContext - Set 1</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    h1 {
      text-align: center;
      color: #2c3e50;
    }
    .question {
      background: #fff;
      border-left: 5px solid #3498db;
      padding: 20px;
      margin: 20px auto;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      max-width: 900px;
      border-radius: 8px;
    }
    .question h2 {
      margin-top: 0;
      color: #2980b9;
    }
    pre {
      background: #f4f4f4;
      padding: 15px;
      overflow-x: auto;
      border-radius: 5px;
    }
    code {
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>React useContext – Questions Set 1</h1>

  <div class="question">
    <h2>1. What is useContext in React?</h2>
    <p><code>useContext</code> is a React Hook that allows you to access the value of a context directly inside functional components without needing to use <code>&lt;Context.Consumer&gt;</code>.</p>
    <pre><code>import React, { useContext } from 'react';

const ThemeContext = React.createContext('light');

function ThemedComponent() {
  const theme = useContext(ThemeContext);
  return &lt;div&gt;Current theme: {theme}&lt;/div&gt;;
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;ThemedComponent /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
  </div>

  <div class="question">
    <h2>2. How to share data between components using useContext?</h2>
    <p>You can use <code>useContext</code> with <code>Context.Provider</code> to pass data through the component tree without having to pass props down manually.</p>
    <pre><code>import React, { useContext } from 'react';

const UserContext = React.createContext();

function Profile() {
  const user = useContext(UserContext);
  return &lt;p&gt;Hello, {user.name}&lt;/p&gt;;
}

function App() {
  const user = { name: 'Manuela', age: 30 };
  return (
    &lt;UserContext.Provider value={user}&gt;
      &lt;Profile /&gt;
    &lt;/UserContext.Provider&gt;
  );
}

export default App;</code></pre>
  </div>

  <div class="question">
    <h2>3. Can useContext be used with multiple contexts?</h2>
    <p>Yes, you can use multiple contexts by calling <code>useContext</code> multiple times within a component.</p>
    <pre><code>import React, { useContext } from 'react';

const ThemeContext = React.createContext('light');
const LanguageContext = React.createContext('en');

function Settings() {
  const theme = useContext(ThemeContext);
  const language = useContext(LanguageContext);
  return &lt;p&gt;Theme: {theme}, Language: {language}&lt;/p&gt;;
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;LanguageContext.Provider value="es"&gt;
        &lt;Settings /&gt;
      &lt;/LanguageContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
  </div>

  <div class="question">
    <h2>4. How to update context values dynamically?</h2>
    <p>You can manage the context value with a state and pass the updater function through the context.</p>
    <pre><code>import React, { createContext, useState, useContext } from 'react';

const CountContext = createContext();

function Counter() {
  const { count, setCount } = useContext(CountContext);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [count, setCount] = useState(0);

  return (
    &lt;CountContext.Provider value={{ count, setCount }}&gt;
      &lt;Counter /&gt;
    &lt;/CountContext.Provider&gt;
  );
}

export default App;</code></pre>
  </div>

  <div class="question">
    <h2>5. How to structure a reusable Context Provider?</h2>
    <p>It's a good practice to extract context logic into a separate provider component for better reuse and encapsulation.</p>
    <pre><code>import React, { createContext, useContext, useState } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const login = (name) =&gt; setUser({ name });
  const logout = () =&gt; setUser(null);

  return (
    &lt;AuthContext.Provider value={{ user, login, logout }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

export function useAuth() {
  return useContext(AuthContext);
}

// Usage
function Profile() {
  const { user, logout } = useAuth();
  return (
    &lt;div&gt;
      &lt;p&gt;User: {user ? user.name : 'Guest'}&lt;/p&gt;
      {user &amp;&amp; &lt;button onClick={logout}&gt;Logout&lt;/button&gt;}
    &lt;/div&gt;
  );
}

function App() {
  const { login } = useAuth();

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; login('Manuela')}&gt;Login&lt;/button&gt;
      &lt;Profile /&gt;
    &lt;/div&gt;
  );
}

// In main render file
import { AuthProvider } from './AuthContext';
import App from './App';

const Root = () =&gt; (
  &lt;AuthProvider&gt;
    &lt;App /&gt;
  &lt;/AuthProvider&gt;
);

export default Root;</code></pre>
  </div>
  
  <div class="question">
  <h2>6. What are the benefits of using useContext over prop drilling?</h2>
  <p><code>useContext</code> avoids deeply nested props by providing a centralized data store, making the component tree cleaner and easier to maintain.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const SettingsContext = createContext();

function DisplaySettings() {
  const settings = useContext(SettingsContext);
  return &lt;p&gt;Dark Mode: {settings.darkMode ? 'On' : 'Off'}&lt;/p&gt;;
}

function App() {
  const settings = { darkMode: true };

  return (
    &lt;SettingsContext.Provider value={settings}&gt;
      &lt;DisplaySettings /&gt;
    &lt;/SettingsContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>7. Can you use useContext outside of a Context Provider?</h2>
  <p>Technically yes, but it will use the <code>defaultValue</code> provided to <code>createContext</code>. This can be useful for fallback values, but not ideal for real application state.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const LocaleContext = createContext('en');

function LanguageDisplay() {
  const locale = useContext(LocaleContext);
  return &lt;p&gt;Current Language: {locale}&lt;/p&gt;;
}

function App() {
  // Not wrapping with Provider, so 'en' is used as fallback
  return &lt;LanguageDisplay /&gt;;
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>8. How to use useContext with TypeScript?</h2>
  <p>You define a context type and use generic parameters in <code>createContext</code> and <code>useContext</code>.</p>
  <pre><code>import React, { createContext, useContext, useState, ReactNode } from 'react';

type AuthContextType = {
  user: string | null;
  login: (name: string) =&gt; void;
};

const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);

const AuthProvider: React.FC&lt;{ children: ReactNode }&gt; = ({ children }) =&gt; {
  const [user, setUser] = useState&lt;string | null&gt;(null);
  const login = (name: string) =&gt; setUser(name);

  return (
    &lt;AuthContext.Provider value={{ user, login }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
};

function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
}

function App() {
  const { user, login } = useAuth();
  return (
    &lt;div&gt;
      &lt;p&gt;User: {user}&lt;/p&gt;
      &lt;button onClick={() =&gt; login('Manuela')}&gt;Login&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default function Root() {
  return (
    &lt;AuthProvider&gt;
      &lt;App /&gt;
    &lt;/AuthProvider&gt;
  );
}</code></pre>
</div>

<div class="question">
  <h2>9. How to consume context in deeply nested components?</h2>
  <p>Wrap the entire component tree with the provider, and use <code>useContext</code> in any nested component.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const AppContext = createContext();

function ChildComponent() {
  const appData = useContext(AppContext);
  return &lt;p&gt;App version: {appData.version}&lt;/p&gt;;
}

function MiddleComponent() {
  return &lt;ChildComponent /&gt;;
}

function App() {
  const data = { version: '1.0.0' };

  return (
    &lt;AppContext.Provider value={data}&gt;
      &lt;MiddleComponent /&gt;
    &lt;/AppContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>10. Can useContext be used with custom hooks?</h2>
  <p>Yes, you can wrap <code>useContext</code> inside a custom hook to encapsulate and reuse logic easily.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const PreferencesContext = createContext();

export function usePreferences() {
  return useContext(PreferencesContext);
}

function PreferencesProvider({ children }) {
  const [darkMode, setDarkMode] = useState(false);
  const toggleDarkMode = () =&gt; setDarkMode(!darkMode);

  return (
    &lt;PreferencesContext.Provider value={{ darkMode, toggleDarkMode }}&gt;
      {children}
    &lt;/PreferencesContext.Provider&gt;
  );
}

function PreferencesPanel() {
  const { darkMode, toggleDarkMode } = usePreferences();
  return (
    &lt;div&gt;
      &lt;p&gt;Dark mode is {darkMode ? 'enabled' : 'disabled'}&lt;/p&gt;
      &lt;button onClick={toggleDarkMode}&gt;Toggle Dark Mode&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;PreferencesProvider&gt;
      &lt;PreferencesPanel /&gt;
    &lt;/PreferencesProvider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>11. How does useContext work behind the scenes?</h2>
  <p>Internally, <code>useContext</code> uses the current value of the nearest matching <code>Context.Provider</code> above the calling component in the tree, tracked via React’s context reconciliation.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const MessageContext = createContext('Default Message');

function MessageDisplay() {
  const message = useContext(MessageContext);
  return &lt;p&gt;Message: {message}&lt;/p&gt;;
}

function App() {
  return (
    &lt;MessageContext.Provider value="Hello from Context!"&gt;
      &lt;MessageDisplay /&gt;
    &lt;/MessageContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>12. How to reset context to its default value?</h2>
  <p>To reset a context, stop rendering the <code>Provider</code> or pass the default value again manually.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const CounterContext = createContext(0);

function CounterDisplay() {
  const count = useContext(CounterContext);
  return &lt;p&gt;Counter: {count}&lt;/p&gt;;
}

function App() {
  const [reset, setReset] = useState(false);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setReset(!reset)}&gt;{reset ? 'Enable' : 'Reset'} Context&lt;/button&gt;
      {reset ? (
        &lt;CounterDisplay /&gt; {/* uses default 0 */}
      ) : (
        &lt;CounterContext.Provider value={42}&gt;
          &lt;CounterDisplay /&gt;
        &lt;/CounterContext.Provider&gt;
      )}
    &lt;/div&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>13. How to nest context providers?</h2>
  <p>You can nest multiple <code>Provider</code>s and access each context using its respective hook.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const ThemeContext = createContext('light');
const AuthContext = createContext(null);

function Info() {
  const theme = useContext(ThemeContext);
  const user = useContext(AuthContext);
  return &lt;p&gt;Theme: {theme}, User: {user}&lt;/p&gt;;
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;AuthContext.Provider value="Manuela"&gt;
        &lt;Info /&gt;
      &lt;/AuthContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>14. What happens if context value changes?</h2>
  <p>Any component using <code>useContext</code> will re-render when the context value changes.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const CountContext = createContext(0);

function DisplayCount() {
  const count = useContext(CountContext);
  return &lt;p&gt;Count is {count}&lt;/p&gt;;
}

function App() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;CountContext.Provider value={count}&gt;
        &lt;DisplayCount /&gt;
      &lt;/CountContext.Provider&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>15. How to prevent unnecessary re-renders when using useContext?</h2>
  <p>To optimize, split context into smaller contexts or memoize values passed to <code>Provider</code>.</p>
  <pre><code>import React, { createContext, useContext, useMemo, useState } from 'react';

const UserContext = createContext();

function UserDisplay() {
  const user = useContext(UserContext);
  return &lt;p&gt;User: {user.name}&lt;/p&gt;;
}

function App() {
  const [name, setName] = useState('Manuela');
  const [otherState, setOtherState] = useState(0);

  const user = useMemo(() =&gt; ({ name }), [name]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setOtherState(otherState + 1)}&gt;Update Unrelated State&lt;/button&gt;
      &lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;
      &lt;UserContext.Provider value={user}&gt;
        &lt;UserDisplay /&gt;
      &lt;/UserContext.Provider&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>16. Can useContext be used with asynchronous data?</h2>
  <p>Yes, you can use <code>useContext</code> with asynchronous data by using <code>useEffect</code> to fetch data and updating the context value.</p>
  <pre><code>import React, { createContext, useContext, useState, useEffect } from 'react';

const DataContext = createContext(null);

function DataDisplay() {
  const data = useContext(DataContext);
  return data ? &lt;p&gt;Data: {data.message}&lt;/p&gt; : &lt;p&gt;Loading...&lt;/p&gt;;
}

function App() {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    fetch('/api/data')
      .then(res =&gt; res.json())
      .then(data =&gt; setData(data));
  }, []);

  return (
    &lt;DataContext.Provider value={data}&gt;
      &lt;DataDisplay /&gt;
    &lt;/DataContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>17. Can useContext be used in a functional component with hooks?</h2>
  <p>Yes, <code>useContext</code> is specifically designed for use with functional components in React, especially when combined with other hooks like <code>useState</code> or <code>useEffect</code>.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

function ThemeToggle() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState('dark');
  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;ThemeToggle /&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'dark' ? 'light' : 'dark')}&gt;Toggle Theme&lt;/button&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>18. How do you handle errors when using useContext?</h2>
  <p>Errors in context can be handled by checking the context value before using it. If it’s undefined, you can display an error message or provide fallback content.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const DataContext = createContext();

function DataDisplay() {
  const data = useContext(DataContext);
  if (!data) {
    return &lt;p&gt;Error: Data is unavailable&lt;/p&gt;;
  }
  return &lt;p&gt;Data: {data}&lt;/p&gt;;
}

function App() {
  return (
    &lt;DataContext.Provider value={null}&gt; {/* This will trigger the error message */}
      &lt;DataDisplay /&gt;
    &lt;/DataContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>19. How can you use multiple contexts in a single component?</h2>
  <p>You can consume multiple contexts in a component by using <code>useContext</code> for each of them independently.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const ThemeContext = createContext('light');
const UserContext = createContext('Guest');

function UserProfile() {
  const theme = useContext(ThemeContext);
  const user = useContext(UserContext);
  return &lt;p&gt;User: {user}, Theme: {theme}&lt;/p&gt;;
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;UserContext.Provider value="Manuela"&gt;
        &lt;UserProfile /&gt;
      &lt;/UserContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>20. Can you dynamically change the value of context in a component?</h2>
  <p>Yes, the value passed to the context provider can be dynamically changed by using state or any other variable that updates during the component's lifecycle.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState('light');
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;Toggle Theme&lt;/button&gt;
      &lt;ThemeContext.Provider value={theme}&gt;
        &lt;ThemeDisplay /&gt;
      &lt;/ThemeContext.Provider&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>
</div>


<div class="question">
  <h2>21. Can you use useContext with a default value for a global state?</h2>
  <p>Yes, you can use <code>useContext</code> with a default value to create a global state that can be accessed throughout your application, even if it's not explicitly set by a <code>Provider</code>.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const GlobalStateContext = createContext('default state');

function DisplayState() {
  const state = useContext(GlobalStateContext);
  return &lt;p&gt;Global State: {state}&lt;/p&gt;;
}

function App() {
  return (
    &lt;GlobalStateContext.Provider value="custom state"&gt;
      &lt;DisplayState /&gt;
    &lt;/GlobalStateContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>22. How to combine useContext with useReducer for state management?</h2>
  <p>Combining <code>useContext</code> with <code>useReducer</code> allows you to manage complex state logic globally and share it across multiple components.</p>
  <pre><code>import React, { createContext, useContext, useReducer } from 'react';

const CountContext = createContext();

const countReducer = (state, action) =&gt; {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

function CountProvider({ children }) {
  const [state, dispatch] = useReducer(countReducer, { count: 0 });

  return (
    &lt;CountContext.Provider value={{ state, dispatch }}&gt;
      {children}
    &lt;/CountContext.Provider&gt;
  );
}

function Counter() {
  const { state, dispatch } = useContext(CountContext);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;Increment&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;CountProvider&gt;
      &lt;Counter /&gt;
    &lt;/CountProvider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>23. Can you pass functions as context values?</h2>
  <p>Yes, you can pass functions as context values. This is commonly used for handling actions such as updates or events across components.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const CounterContext = createContext();

function CounterDisplay() {
  const { count, increment } = useContext(CounterContext);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [count, setCount] = useState(0);
  const increment = () =&gt; setCount(count + 1);

  return (
    &lt;CounterContext.Provider value={{ count, increment }}&gt;
      &lt;CounterDisplay /&gt;
    &lt;/CounterContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>24. Can you consume context in class components?</h2>
  <p>Yes, you can consume context in class components by using the <code>static contextType</code> property or <code>Context.Consumer</code>.</p>
  <pre><code>import React, { createContext, Component } from 'react';

const ThemeContext = createContext('light');

class ThemeDisplay extends Component {
  static contextType = ThemeContext;

  render() {
    return &lt;p&gt;Current Theme: {this.context}&lt;/p&gt;;
  }
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>25. How do you ensure type safety when using useContext in TypeScript?</h2>
  <p>In TypeScript, you can use generics to ensure type safety when creating the context and consuming it with <code>useContext</code>.</p>
  <pre><code>import React, { createContext, useContext, ReactNode } from 'react';

type Theme = 'light' | 'dark';

const ThemeContext = createContext<Theme>('light');

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>26. How can you update context values from a nested component?</h2>
  <p>You can update context values by accessing the setter function or update function passed via context in nested components.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext({ theme: 'light', setTheme: () =&gt; {} });

function ThemeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);
  return (
    &lt;div&gt;
      &lt;p&gt;Current Theme: {theme}&lt;/p&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;Toggle Theme&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      &lt;ThemeToggle /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>27. Can useContext be used for localization (i18n) in React?</h2>
  <p>Yes, you can use <code>useContext</code> for localization by providing the current language or translation functions via context.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const LanguageContext = createContext('en');

function Greeting() {
  const language = useContext(LanguageContext);
  const greeting = language === 'en' ? 'Hello' : 'Hola';
  return &lt;p&gt;{greeting}, World!&lt;/p&gt;;
}

function App() {
  const [language, setLanguage] = useState('en');

  return (
    &lt;LanguageContext.Provider value={language}&gt;
      &lt;Greeting /&gt;
      &lt;button onClick={() =&gt; setLanguage(language === 'en' ? 'es' : 'en')}&gt;Change Language&lt;/button&gt;
    &lt;/LanguageContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>28. How does useContext compare to prop drilling in React?</h2>
  <p>Unlike prop drilling, <code>useContext</code> allows you to avoid passing props through many layers of components, making your code more maintainable and reducing redundancy.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const ThemeContext = createContext('light');

function Button() {
  const theme = useContext(ThemeContext);
  return &lt;button style={{ background: theme === 'dark' ? 'black' : 'white' }}&gt;Click Me&lt;/button&gt;;
}

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;Button /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>29. Can you use useContext to manage form states?</h2>
  <p>Yes, you can use <code>useContext</code> to manage form states and pass form data to various components within the form.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const FormContext = createContext();

function InputField() {
  const { formData, handleChange } = useContext(FormContext);
  return (
    &lt;div&gt;
      &lt;label&gt;Name:&lt;/label&gt;
      &lt;input type="text" value={formData.name} onChange={handleChange} name="name" /&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [formData, setFormData] = useState({ name: '' });

  const handleChange = (e) =&gt; {
    const { name, value } = e.target;
    setFormData((prev) =&gt; ({ ...prev, [name]: value }));
  };

  return (
    &lt;FormContext.Provider value={{ formData, handleChange }}&gt;
      &lt;InputField /&gt;
    &lt;/FormContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>30. Can useContext work with non-primitive values (objects, arrays)?</h2>
  <p>Yes, you can pass objects or arrays as context values. However, be careful with re-renders when you mutate objects or arrays directly. It’s better to return a new object/array on changes.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const TodoContext = createContext([]);

function TodoList() {
  const todos = useContext(TodoContext);
  return (
    &lt;ul&gt;
      {todos.map((todo, index) =&gt; (
        &lt;li key={index}&gt;{todo}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

function App() {
  const [todos, setTodos] = useState(['Learn React', 'Learn useContext']);

  return (
    &lt;TodoContext.Provider value={todos}&gt;
      &lt;TodoList /&gt;
    &lt;/TodoContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>31. Can you create a custom hook to consume context?</h2>
  <p>Yes, you can create a custom hook to encapsulate the logic of consuming context, making the code cleaner and reusable.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

function useTheme() {
  return useContext(ThemeContext);
}

function ThemeDisplay() {
  const theme = useTheme();
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>32. How do you handle context changes that trigger a re-render?</h2>
  <p>React will re-render all components that consume context when the context value changes. To optimize performance, ensure that the context value is updated only when necessary and avoid unnecessary re-renders.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

function ThemeToggle() {
  const theme = useContext(ThemeContext);
  console.log('Rendered: ThemeToggle');
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState('light');

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;ThemeToggle /&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;Toggle Theme&lt;/button&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>33. How can you use useContext with TypeScript for strongly typed context values?</h2>
  <p>With TypeScript, you can define the context value type explicitly to ensure type safety when using <code>useContext</code>.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

type Theme = 'light' | 'dark';

const ThemeContext = createContext<Theme>('light');

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState<Theme>('light');

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>34. Can useContext be used with React's Suspense for async data fetching?</h2>
  <p>Yes, you can use <code>useContext</code> along with React Suspense to handle asynchronous data fetching by suspending the rendering of components until the context value is available.</p>
  <pre><code>import React, { createContext, useContext, useState, useEffect } from 'react';

const DataContext = createContext(null);

function DataDisplay() {
  const data = useContext(DataContext);
  if (!data) {
    throw new Promise(resolve =&gt; setTimeout(resolve, 1000)); // Simulate async loading
  }
  return &lt;p&gt;Data: {data.message}&lt;/p&gt;;
}

function App() {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    setTimeout(() =&gt; setData({ message: 'Fetched Data' }), 2000);
  }, []);

  return (
    &lt;React.Suspense fallback=&lt;p&gt;Loading...&lt;/p&gt;&gt;
      &lt;DataContext.Provider value={data}&gt;
        &lt;DataDisplay /&gt;
      &lt;/DataContext.Provider&gt;
    &lt;/React.Suspense&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>35. How do you provide context values that depend on state changes?</h2>
  <p>You can provide context values that depend on state changes by using React's state management inside the context provider. Whenever the state updates, the context value will automatically update as well.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const CountContext = createContext();

function CountDisplay() {
  const { count } = useContext(CountContext);
  return &lt;p&gt;Count: {count}&lt;/p&gt;;
}

function App() {
  const [count, setCount] = useState(0);

  return (
    &lt;CountContext.Provider value={{ count }}&gt;
      &lt;CountDisplay /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/CountContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>


<div class="question">
  <h2>36. Can useContext be used with React Router for passing route-specific data?</h2>
  <p>Yes, you can use <code>useContext</code> alongside React Router to share route-specific data across components.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';
import { BrowserRouter as Router, Route, Link, Switch } from 'react-router-dom';

const UserContext = createContext(null);

function UserProfile() {
  const user = useContext(UserContext);
  return &lt;p&gt;User: {user ? user.name : 'Guest'}&lt;/p&gt;;
}

function HomePage() {
  return &lt;div&gt;Home Page&lt;/div&gt;;
}

function App() {
  const [user, setUser] = useState({ name: 'John Doe' });

  return (
    &lt;UserContext.Provider value={user}&gt;
      &lt;Router&gt;
        &lt;nav&gt;
          &lt;Link to="/"&gt;Home&lt;/Link&gt;
        &lt;/nav&gt;
        &lt;Switch&gt;
          &lt;Route path="/" exact component={HomePage} /&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/UserContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>37. How do you prevent unnecessary re-renders when using useContext?</h2>
  <p>To prevent unnecessary re-renders, make sure that the context value is memoized or avoid creating new objects/arrays directly inside the context provider value.</p>
  <pre><code>import React, { createContext, useContext, useState, useMemo } from 'react';

const ThemeContext = createContext();

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState('light');
  const value = useMemo(() =&gt; ({ theme, setTheme }), [theme]); // Memoize value to prevent unnecessary re-renders

  return (
    &lt;ThemeContext.Provider value={value}&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>38. How can useContext help when working with deeply nested components?</h2>
  <p>useContext can help you avoid prop drilling by providing a way to pass data directly to deeply nested components without the need to pass it through every intermediary component.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

function NestedComponent() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme, setTheme] = useState('dark');

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;NestedComponent /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>39. Can you combine multiple contexts in a single provider?</h2>
  <p>Yes, you can combine multiple contexts by nesting their providers or using a custom provider that aggregates the values from multiple contexts.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();
const LanguageContext = createContext();

function Settings() {
  const theme = useContext(ThemeContext);
  const language = useContext(LanguageContext);
  return &lt;p&gt;Theme: {theme}, Language: {language}&lt;/p&gt;;
}

function App() {
  const [theme] = useState('light');
  const [language] = useState('en');

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;LanguageContext.Provider value={language}&gt;
        &lt;Settings /&gt;
      &lt;/LanguageContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>40. How do you use useContext with local state updates?</h2>
  <p>You can use <code>useContext</code> to pass local state values and update functions through context, enabling state management at a global level.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const CounterContext = createContext();

function Counter() {
  const { count, setCount } = useContext(CounterContext);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [count, setCount] = useState(0);

  return (
    &lt;CounterContext.Provider value={{ count, setCount }}&gt;
      &lt;Counter /&gt;
    &lt;/CounterContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>41. How do you use useContext with a default value?</h2>
  <p>When creating a context, you can set a default value, which will be used if the context consumer doesn't have a matching provider higher in the tree.</p>
  <pre><code>import React, { createContext, useContext } from 'react';

const ThemeContext = createContext('light'); // Default value

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  return (
    &lt;div&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>42. Can you use useContext with complex objects or arrays?</h2>
  <p>Yes, you can use <code>useContext</code> to pass complex objects or arrays as context values. Just ensure that updates to these objects/arrays are handled properly to avoid unnecessary re-renders.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const UserContext = createContext();

function UserInfo() {
  const user = useContext(UserContext);
  return &lt;p&gt;User: {user.name}, Age: {user.age}&lt;/p&gt;;
}

function App() {
  const [user] = useState({ name: 'Jane Doe', age: 25 });

  return (
    &lt;UserContext.Provider value={user}&gt;
      &lt;UserInfo /&gt;
    &lt;/UserContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>43. Can useContext be used with multiple values in one context?</h2>
  <p>Yes, you can use a single context to pass multiple values by grouping them in an object or array.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const AppContext = createContext();

function UserProfile() {
  const { theme, language } = useContext(AppContext);
  return &lt;p&gt;Theme: {theme}, Language: {language}&lt;/p&gt;;
}

function App() {
  const [settings] = useState({ theme: 'dark', language: 'en' });

  return (
    &lt;AppContext.Provider value={settings}&gt;
      &lt;UserProfile /&gt;
    &lt;/AppContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>44. How can you manage context values that require updates in multiple components?</h2>
  <p>You can manage context values by providing setter functions for updates and accessing them through useContext, allowing multiple components to update the context state.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const CounterContext = createContext();

function CounterDisplay() {
  const { count } = useContext(CounterContext);
  return &lt;p&gt;Count: {count}&lt;/p&gt;;
}

function IncrementButton() {
  const { increment } = useContext(CounterContext);
  return &lt;button onClick={increment}&gt;Increment&lt;/button&gt;;
}

function App() {
  const [count, setCount] = useState(0);
  const increment = () =&gt; setCount(count + 1);

  return (
    &lt;CounterContext.Provider value={{ count, increment }}&gt;
      &lt;CounterDisplay /&gt;
      &lt;IncrementButton /&gt;
    &lt;/CounterContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>45. How do you manage large context values with performance optimization?</h2>
  <p>To optimize performance, ensure that context values are minimal, and use memoization techniques like <code>useMemo</code> to avoid unnecessary re-renders.</p>
  <pre><code>import React, { createContext, useContext, useState, useMemo } from 'react';

const DataContext = createContext();

function DataDisplay() {
  const data = useContext(DataContext);
  return &lt;p&gt;Data: {data.message}&lt;/p&gt;;
}

function App() {
  const [data, setData] = useState({ message: 'Initial Data' });
  const value = useMemo(() =&gt; ({ message: data.message }), [data.message]);

  return (
    &lt;DataContext.Provider value={value}&gt;
      &lt;DataDisplay /&gt;
      &lt;button onClick={() =&gt; setData({ message: 'Updated Data' })}&gt;Update Data&lt;/button&gt;
    &lt;/DataContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>46. How do you manage context values with a dynamically changing structure?</h2>
  <p>You can manage context values with dynamic structures by updating the state inside the provider as needed, ensuring that the structure is flexible and can be updated in response to changes.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const DynamicContext = createContext();

function DynamicDisplay() {
  const data = useContext(DynamicContext);
  return &lt;p&gt;Data: {JSON.stringify(data)}&lt;/p&gt;;
}

function App() {
  const [data, setData] = useState({ message: 'Initial Message' });

  return (
    &lt;DynamicContext.Provider value={data}&gt;
      &lt;DynamicDisplay /&gt;
      &lt;button onClick={() =&gt; setData({ message: 'Updated Message' })}&gt;Update Data&lt;/button&gt;
    &lt;/DynamicContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>47. Can you use useContext with component libraries or third-party libraries?</h2>
  <p>Yes, you can integrate useContext with component libraries or third-party libraries, providing a simple way to manage global state across different parts of your app.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';
import { Button } from 'your-component-library';

const ThemeContext = createContext('light');

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return &lt;Button className={theme}&gt;Click me&lt;/Button&gt;;
}

function App() {
  const [theme, setTheme] = useState('light');

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;ThemedButton /&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;Toggle Theme&lt;/button&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>48. How do you use useContext for form handling and managing form state?</h2>
  <p>You can use useContext to manage form state globally, allowing multiple form components to share and update the same state.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const FormContext = createContext();

function FormInput() {
  const { formState, updateFormState } = useContext(FormContext);
  return (
    &lt;input
      value={formState.name}
      onChange={(e) =&gt; updateFormState({ name: e.target.value })}
    /&gt;
  );
}

function App() {
  const [formState, setFormState] = useState({ name: '' });
  const updateFormState = (newState) =&gt; setFormState({ ...formState, ...newState });

  return (
    &lt;FormContext.Provider value={{ formState, updateFormState }}&gt;
      &lt;FormInput /&gt;
      &lt;p&gt;Form Value: {formState.name}&lt;/p&gt;
    &lt;/FormContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>49. How can you avoid unnecessary re-renders when updating context values?</h2>
  <p>To avoid unnecessary re-renders, ensure that the context value only changes when necessary, and use <code>useMemo</code> or <code>React.memo</code> to prevent unnecessary updates to consumers.</p>
  <pre><code>import React, { createContext, useContext, useState, useMemo } from 'react';

const CounterContext = createContext();

function Counter() {
  const { count, increment } = useContext(CounterContext);
  console.log('Rendered: Counter');
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [count, setCount] = useState(0);
  const increment = () =&gt; setCount(count + 1);
  const value = useMemo(() =&gt; ({ count, increment }), [count]); // Memoize value

  return (
    &lt;CounterContext.Provider value={value}&gt;
      &lt;Counter /&gt;
    &lt;/CounterContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>

<div class="question">
  <h2>50. Can you use useContext with server-side rendering (SSR) in React?</h2>
  <p>Yes, you can use <code>useContext</code> in server-side rendered React applications, but make sure that the context values are initialized correctly on the server and passed to the client during hydration.</p>
  <pre><code>import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  return &lt;p&gt;Current Theme: {theme}&lt;/p&gt;;
}

function App() {
  const [theme] = useState('light'); // This state can come from server-side data

  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;ThemeDisplay /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

export default App;</code></pre>
</div>




</body>
</html>
